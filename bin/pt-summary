#!/bin/sh

# This program is part of Percona Toolkit: http://www.percona.com/software/
# See "COPYRIGHT, LICENSE, AND WARRANTY" at the end of this file for legal
# notices and disclaimers.

# ########################################################################
# Globals, settings, helper functions
# ########################################################################
POSIXLY_CORRECT=1
export POSIXLY_CORRECT

# The awk code for fuzzy rounding.  (It's used in a few places, so makes sense
# not to duplicate).  It fuzzy-rounds the variable named fuzzy_var.  It goes in
# steps of 5, 10, 25, then repeats by a factor of 10 larger (50, 100, 250), and
# so on, until it finds a number that's large enough.  The pattern is slightly
# broken between the initial 1 and 50, because rounding to the nearest 2.5
# doesn't seem right to me.
fuzzy_formula='
   rounded = 0;
   if (fuzzy_var <= 10 ) {
      rounded   = 1;
   }
   factor = 1;
   while ( rounded == 0 ) {
      if ( fuzzy_var <= 50 * factor ) {
         fuzzy_var = sprintf("%.0f", fuzzy_var / (5 * factor)) * 5 * factor;
         rounded   = 1;
      }
      else if ( fuzzy_var <= 100  * factor) {
         fuzzy_var = sprintf("%.0f", fuzzy_var / (10 * factor)) * 10 * factor;
         rounded   = 1;
      }
      else if ( fuzzy_var <= 250  * factor) {
         fuzzy_var = sprintf("%.0f", fuzzy_var / (25 * factor)) * 25 * factor;
         rounded   = 1;
      }
      factor = factor * 10;
   }'

# Does fuzzy rounding: rounds to nearest interval, but the interval gets larger
# as the number gets larger.  This is to make things easier to diff.
fuzz () {
   echo $1 | $AP_AWK "{fuzzy_var=\$1; ${fuzzy_formula} print fuzzy_var;}"
}

# The temp files are for storing working results so we don't call commands many
# times (gives inconsistent results, maybe adds load on things I don't want to
# such as RAID controllers).  They must not exist -- if they did, someone would
# symlink them to /etc/passwd and then run this program as root.  Call this
# function with "rm" or "touch" as an argument.
temp_files() {
   for file in /tmp/percona-toolkit /tmp/percona-toolkit2; do
      case "$1" in
      touch)
         if ! touch "${file}"; then
            echo "I can't make my temp file ${file}";
            exit 1;
         fi
         ;;
      rm)
         rm -f "${file}"
         ;;
      esac
   done
}

# Print a space-padded string into $line.  Then translate spaces to hashes, and
# underscores to spaces.  End result is a line of hashes with words at the
# start.
section () {
   echo "$1" | awk '{l=sprintf("#_%-60s", $0 "_"); print l}' | sed -e 's/ /#/g' -e 's/_/ /g'
}

# Print a "name | value" line.
name_val() {
   printf "%12s | %s\n" "$1" "$(echo $2)"
}

# Converts a value to units of power of 2.  Arg 1: the value.  Arg 2: precision (defaults to 2).
shorten() {
   echo $@ | awk '{
      unit = "k";
      size = 1024;
      val  = $1;
      prec = 2;
      if ( $2 ~ /./ ) {
         prec = $2;
      }
      if ( val >= 1099511627776 ) {
         size = 1099511627776;
         unit = "T";
      }
      else if ( val >= 1073741824 ) {
         size = 1073741824;
         unit = "G";
      }
      else if ( val >= 1048576 ) {
         size = 1048576;
         unit = "M";
      }
      printf "%." prec "f%s", val / size, unit;
   }'
}

# ##############################################################################
# Function to take a file and collapse it into an aggregated list.  This
# function works on $1, which it expects to be created with 'sort |
# uniq -c'.  Leading whitespace is deleted.  The result will look like
# "4xabc, 1xdef"  Copy any changes to 'mysql-summary' too.
# ##############################################################################
group_concat () {
   sed -e '{H; $!d}' -e 'x' -e 's/\n[[:space:]]*\([[:digit:]]*\)[[:space:]]*/, \1x/g' -e 's/[[:space:]][[:space:]]*/ /g' -e 's/, //' ${1}
   # In words: save the whole file into the hold space,
   # {H; $!d}
   # Swap it back into the pattern space,
   # x
   # Join lines with a comma, delete leading whitespace, and put an 'x' between
   # the number and the text that follows,
   # s/\n[[:space:]]*\([[:digit:]]*\)[[:space:]]*/, \1x/g
   # Collapse whitespace,
   # s/[[:space:]][[:space:]]*/ /g
   # And delete the leading comma-space.
   # s/, //
}

# ##############################################################################
# Functions for parsing specific files and getting desired info from them.
# These are called from within main() and are separated so they can be tested
# easily.  The calling convention is that the data they need to run is prepared
# first by putting it into /tmp/percona-toolkit.  Then code that's testing just needs to
# put sample data into /tmp/percona-toolkit and call it.
# ##############################################################################
   
# ##############################################################################
# Parse Linux's /proc/cpuinfo, which should be stored in /tmp/percona-toolkit.
# ##############################################################################
parse_proc_cpuinfo () {
   local file=$1
   # Physical processors are indicated by distinct 'physical id'.  Virtual CPUs
   # are indicated by paragraphs -- one per paragraph.  We assume that all
   # processors are identical, i.e. that there are not some processors with dual
   # cores and some with quad cores.
   virtual=$(grep -c ^processor $file);
   physical=$(grep 'physical id' $file | sort -u | wc -l);
   cores=$(grep 'cpu cores' $file | head -n 1 | cut -d: -f2);

   # Older kernel won't have 'physical id' or 'cpu cores'.
   if [ "${physical}" = "0" ]; then physical=${virtual}; fi
   if [ -z "${cores}" ]; then cores=0; fi

   # Test for HTT; cannot trust the 'ht' flag.  If physical * cores < virtual,
   # then hyperthreading is in use.
   cores=$((${cores} * ${physical}));
   if [ ${cores} -gt 0 -a $cores -lt $virtual ]; then htt=yes; else htt=no; fi

   name_val "Processors" "physical = ${physical}, cores = ${cores}, virtual = ${virtual}, hyperthreading = ${htt}"

   awk -F: '/cpu MHz/{print $2}' $file \
      | sort | uniq -c > "$file.unq"
   name_val "Speeds" "$(group_concat "$file.unq")"

   awk -F: '/model name/{print $2}' $file \
      | sort | uniq -c > "$file.unq"
   name_val "Models" "$(group_concat "$file.unq")"

   awk -F: '/cache size/{print $2}' $file \
      | sort | uniq -c > "$file.unq"
   name_val "Caches" "$(group_concat "$file.unq")"
}

# ##############################################################################
# Parse sysctl -a output on FreeBSD, and format it as CPU info.  The file is the
# first argument.
# ##############################################################################
parse_sysctl_cpu_freebsd() {
   virtual="$(awk '/hw.ncpu/{print $2}' "$1")"
   name_val "Processors" "virtual = ${virtual}"
   name_val "Speeds" "$(awk '/hw.clockrate/{print $2}' "$1")"
   name_val "Models" "$(awk -F: '/hw.model/{print substr($2, 2)}' "$1")"
}

# ##############################################################################
# Parse CPU info from psrinfo -v
# ##############################################################################
parse_psrinfo_cpus() {
   name_val Processors $(grep -c 'Status of .* processor' "$1")
   awk '/operates at/ {
      start = index($0, " at ") + 4;
      end   = length($0) - start - 4
      print substr($0, start, end);
   }' "$1" | sort | uniq -c > /tmp/percona-toolkit2
   name_val "Speeds" "$(group_concat /tmp/percona-toolkit2)"
}

# ##############################################################################
# Parse the output of 'free -b' plus the contents of /proc/meminfo
# ##############################################################################
parse_free_minus_b () {
   local file=$1

   local physical=$(awk '/Mem:/{print $3}' "${file}")
   local swap=$(awk '/Swap:/{print $3}' "${file}")
   local virtual=$(shorten $(($physical + $swap)))

   name_val Total   $(shorten $(awk '/Mem:/{print $2}' "${file}"))
   name_val Free    $(shorten $(awk '/Mem:/{print $4}' "${file}"))
   name_val Used    "physical = $(shorten ${physical}), swap = $(shorten ${swap}), virtual = ${virtual}"
   name_val Buffers $(shorten $(awk '/Mem:/{print $6}' "${file}"))
   name_val Caches  $(shorten $(awk '/Mem:/{print $7}' "${file}"))
   name_val Dirty  "$(awk '/Dirty:/ {print $2, $3}' "${file}")"
}

# ##############################################################################
# Parse FreeBSD memory info from sysctl output.
# ##############################################################################
parse_memory_sysctl_freebsd() {
   physical=$(awk '/hw.realmem:/{print $2}' "${1}")
   mem_hw=$(awk '/hw.physmem:/{print $2}' "${1}")
   mem_used=$(awk '
      /hw.physmem/                   { mem_hw       = $2; }
      /vm.stats.vm.v_inactive_count/ { mem_inactive = $2; }
      /vm.stats.vm.v_cache_count/    { mem_cache    = $2; }
      /vm.stats.vm.v_free_count/     { mem_free     = $2; }
      /hw.pagesize/                  { pagesize     = $2; }
      END {
         mem_inactive *= pagesize;
         mem_cache    *= pagesize;
         mem_free     *= pagesize;
         print mem_hw - mem_inactive - mem_cache - mem_free;
      }
   ' "$1");
   name_val Total   $(shorten ${mem_hw} 1)
   name_val Virtual $(shorten ${physical} 1)
   name_val Used    $(shorten ${mem_used} 1)
}

# ##############################################################################
# Parse memory devices from the output of 'dmidecode'.
# ##############################################################################
parse_dmidecode_mem_devices () {
   local file=$1
   echo "  Locator   Size     Speed             Form Factor   Type          Type Detail"
   echo "  ========= ======== ================= ============= ============= ==========="
   # Print paragraphs containing 'Memory Device\n', extract the desired bits,
   # concatenate them into one long line, then format as a table.  The data
   # comes out in this order for each paragraph:
   # $2  Size         2048 MB
   # $3  Form Factor  <OUT OF SPEC>
   # $4  Locator      DIMM1
   # $5  Type         <OUT OF SPEC>
   # $6  Type Detail  Synchronous
   # $7  Speed        667 MHz (1.5 ns)
   sed    -e '/./{H;$!d;}' \
          -e 'x;/Memory Device\n/!d;' \
          -e 's/: /:/g' \
          -e 's/</{/g' \
          -e 's/>/}/g' \
          -e 's/[ \t]*\n/\n/g' \
       $file \
       | awk -F: '/Size|Type|Form.Factor|Type.Detail|[^ ]Locator/{printf("|%s", $2)}/Speed/{print "|" $2}' \
       | sed -e 's/No Module Installed/{EMPTY}/' \
       | sort \
       | awk -F'|' '{printf("  %-9s %-8s %-17s %-13s %-13s %-8s\n", $4, $2, $7, $3, $5, $6);}'
}

# ##############################################################################
# Parse the output of 'netstat -antp'
# ##############################################################################
parse_ip_s_link () {
   echo "  interface  rx_bytes rx_packets  rx_errors   tx_bytes tx_packets  tx_errors"
   echo "  ========= ========= ========== ========== ========== ========== =========="

   awk "/^[1-9][0-9]*:/ {
      save[\"iface\"] = substr(\$2, 0, index(\$2, \":\") - 1);
      new = 1;
   }
   \$0 !~ /[^0-9 ]/ {
      if ( new == 1 ) {
         new = 0;
         fuzzy_var = \$1; ${fuzzy_formula} save[\"bytes\"] = fuzzy_var;
         fuzzy_var = \$2; ${fuzzy_formula} save[\"packs\"] = fuzzy_var;
         fuzzy_var = \$3; ${fuzzy_formula} save[\"errs\"]  = fuzzy_var;
      }
      else {
         fuzzy_var = \$1; ${fuzzy_formula} tx_bytes   = fuzzy_var;
         fuzzy_var = \$2; ${fuzzy_formula} tx_packets = fuzzy_var;
         fuzzy_var = \$3; ${fuzzy_formula} tx_errors  = fuzzy_var;
         printf \"  %-8s %10d %10d %10d %10d %10d %10d\\n\", save[\"iface\"], save[\"bytes\"], save[\"packs\"], save[\"errs\"], tx_bytes, tx_packets, tx_errors;
      }
   }" $@
}

# ##############################################################################
# Parse the output of 'netstat -antp' which should be in /tmp/percona-toolkit.
# ##############################################################################
parse_netstat () {
   local file=$1
   echo "  Connections from remote IP addresses"
   awk '$1 ~ /^tcp/ && $5 ~ /^[1-9]/ {
      print substr($5, 0, index($5, ":") - 1);
   }' $file | sort | uniq -c \
      | awk "{
         fuzzy_var=\$1;
         ${fuzzy_formula}
         printf \"    %-15s %5d\\n\", \$2, fuzzy_var;
         }" \
      | sort -n -t . -k 1,1 -k 2,2 -k 3,3 -k 4,4
   echo "  Connections to local IP addresses"
   awk '$1 ~ /^tcp/ && $5 ~ /^[1-9]/ {
      print substr($4, 0, index($4, ":") - 1);
   }' $file | sort | uniq -c \
      | awk "{
         fuzzy_var=\$1;
         ${fuzzy_formula}
         printf \"    %-15s %5d\\n\", \$2, fuzzy_var;
         }" \
      | sort -n -t . -k 1,1 -k 2,2 -k 3,3 -k 4,4
   echo "  Connections to top 10 local ports"
   awk '$1 ~ /^tcp/ && $5 ~ /^[1-9]/ {
      print substr($4, index($4, ":") + 1);
   }' $file | sort | uniq -c | sort -rn | head -n10 \
      | awk "{
         fuzzy_var=\$1;
         ${fuzzy_formula}
         printf \"    %-15s %5d\\n\", \$2, fuzzy_var;
         }" | sort
   echo "  States of connections"
   awk '$1 ~ /^tcp/ {
      print $6;
   }' $file | sort | uniq -c | sort -rn \
      | awk "{
         fuzzy_var=\$1;
         ${fuzzy_formula}
         printf \"    %-15s %5d\\n\", \$2, fuzzy_var;
         }" | sort
}

# ##############################################################################
# Parse the joined output of 'mount' and 'df -hP'.  $1 = file; $2 = ostype.
# ##############################################################################
parse_filesystems () {
   # Filesystem names and mountpoints can be very long.  We try to align things
   # as nicely as possible by making columns only as wide as needed.  This
   # requires two passes through the file.  The first pass finds the max size of
   # these columns and prints out a printf spec, and the second prints out the
   # file nicely aligned.
   local file=$1
   local platform=$2

   local spec=$(awk "
      BEGIN {
         device     = 10;
         fstype     = 4;
         options    = 4;
      }
      /./ {
         f_device     = \$1;
         f_fstype     = \$10;
         f_options    = substr(\$11, 2, length(\$11) - 2);
         if ( \"$2\" == \"FreeBSD\" ) {
            f_fstype  = substr(\$9, 2, length(\$9) - 2);
            f_options = substr(\$0, index(\$0, \",\") + 2);
            f_options = substr(f_options, 1, length(f_options) - 1);
         }
         if ( length(f_device) > device ) {
            device=length(f_device);
         }
         if ( length(f_fstype) > fstype ) {
            fstype=length(f_fstype);
         }
         if ( length(f_options) > options ) {
            options=length(f_options);
         }
      }
      END{
         print \"%-\" device \"s %5s %4s %-\" fstype \"s %-\" options \"s %s\";
      }
   " $file)

   awk "
      BEGIN {
         spec=\"  ${spec}\\n\";
         printf spec, \"Filesystem\", \"Size\", \"Used\", \"Type\", \"Opts\", \"Mountpoint\";
      }
      {
         f_fstype     = \$10;
         f_options    = substr(\$11, 2, length(\$11) - 2);
         if ( \"$2\" == \"FreeBSD\" ) {
            f_fstype  = substr(\$9, 2, length(\$9) - 2);
            f_options = substr(\$0, index(\$0, \",\") + 2);
            f_options = substr(f_options, 1, length(f_options) - 1);
         }
         printf spec, \$1, \$2, \$5, f_fstype, f_options, \$6;
      }
   " $file
}

# ##############################################################################
# Parse the output of fdisk -l, which should be in /tmp/percona-toolkit; there might be
# multiple fdisk -l outputs in the file.
# ##############################################################################
parse_fdisk () {
   local file=$1
   awk '
      BEGIN {
         format="%-12s %4s %10s %10s %18s\n";
         printf(format, "Device", "Type", "Start", "End", "Size");
         printf(format, "============", "====", "==========", "==========", "==================");
      }
      /Disk.*bytes/ {
         disk = substr($2, 1, length($2) - 1);
         size = $5;
         printf(format, disk, "Disk", "", "", size);
      }
      /Units/ {
         units = $9;
      }
      /^\/dev/ {
         if ( $2 == "*" ) {
            start = $3;
            end   = $4;
         }
         else {
            start = $2;
            end   = $3;
         }
         printf(format, $1, "Part", start, end, sprintf("%.0f", (end - start) * units));
      }
   ' $file
}

# ##############################################################################
# Parse the output of dmesg, which should be in /tmp/percona-toolkit, and detect
# virtualization.
# ##############################################################################
parse_virtualization_dmesg () {
   local file=$1
   if grep -qi -e vmware -e vmxnet -e 'paravirtualized kernel on vmi' $file; then
      echo "VMWare";
   elif grep -qi -e 'paravirtualized kernel on xen' -e 'Xen virtual console' $file; then
      echo "Xen";
   elif grep -qi qemu $file; then
      echo "QEmu";
   elif grep -qi 'paravirtualized kernel on KVM' $file; then
      echo "KVM";
   elif grep -q VBOX $file; then
      echo "VirtualBox";
   elif grep -qi 'hd.: Virtual .., ATA.*drive' $file; then
      echo "Microsoft VirtualPC";
   fi
}

# ##############################################################################
# Try to figure out if a system is a guest by looking at prtdiag, smbios, etc.
# ##############################################################################
parse_virtualization_generic() {
   if grep -i -e virtualbox "$1" >/dev/null; then
      echo VirtualBox
   elif grep -i -e vmware "$1" >/dev/null; then
      echo VMWare
   fi
}

# ##############################################################################
# Parse the output of lspci, which should be in /tmp/percona-toolkit, and detect
# Ethernet cards.
# ##############################################################################
parse_ethernet_controller_lspci () {
   local file=$1
   grep -i ethernet $file | cut -d: -f3 | while read line; do
      name_val Controller "${line}"
   done
}

# ##############################################################################
# Parse the output of lspci, which should be in /tmp/percona-toolkit, and detect RAID
# controllers.
# ##############################################################################
parse_raid_controller_lspci () {
   local file=$1
   if grep -q "RAID bus controller: LSI Logic / Symbios Logic MegaRAID SAS" $file; then
      echo 'LSI Logic MegaRAID SAS'
   elif grep -q "Fusion-MPT SAS" $file; then
      echo 'Fusion-MPT SAS'
   elif grep -q "RAID bus controller: LSI Logic / Symbios Logic Unknown" $file; then
      echo 'LSI Logic Unknown'
   elif grep -q "RAID bus controller: Adaptec AAC-RAID" $file; then
      echo 'AACRAID'
   elif grep -q "3ware [0-9]* Storage Controller" $file; then
      echo '3Ware'
   elif grep -q "Hewlett-Packard Company Smart Array" $file; then
      echo 'HP Smart Array'
   elif grep -q " RAID bus controller: " $file; then
      awk -F: '/RAID bus controller\:/ {print $3" "$5" "$6}' $file
   fi
}

# ##############################################################################
# Parse the output of dmesg, which should be in /tmp/percona-toolkit, and detect RAID
# controllers.
# ##############################################################################
parse_raid_controller_dmesg () {
   local file=$1
   pat='scsi[0-9].*: .*'
   if grep -qi "${pat}megaraid" $file; then
      echo 'LSI Logic MegaRAID SAS'
   elif grep -q "Fusion MPT SAS" $file; then
      echo 'Fusion-MPT SAS'
   elif grep -q "${pat}aacraid" $file; then
      echo 'AACRAID'
   elif grep -q "${pat}3ware [0-9]* Storage Controller" $file; then
      echo '3Ware'
   fi
}

# ##############################################################################
# Parse the output of "hpacucli ctrl all show config", which should be stored in
# /tmp/percona-toolkit
# ##############################################################################
parse_hpacucli () {
   local file=$1
   grep 'logicaldrive\|physicaldrive' $file
}

# ##############################################################################
# Parse the output of arcconf, which should be stored in /tmp/percona-toolkit
# ##############################################################################
parse_arcconf () {
   local file=$1
   model=$(awk -F: '/Controller Model/{print $2}' $file)
   chan="$(awk -F: '/Channel description/{print $2}' $file)"
   cache="$(awk -F: '/Installed memory/{print $2}' $file)"
   status="$(awk -F: '/Controller Status/{print $2}' $file)"
   name_val Specs "${model/ /},${chan},${cache} cache,${status}"

   battery=$(grep -A5 'Controller Battery Info' $file \
      | awk '/Capacity remaining/ {c=$4}
             /Status/             {s=$3}
             /Time remaining/     {t=sprintf("%dd%dh%dm", $7, $9, $11)}
             END                  {printf("%d%%, %s remaining, %s", c, t, s)}')
   name_val Battery "${battery}"

   # ###########################################################################
   # Logical devices
   # ###########################################################################
   echo
   echo "  LogicalDev Size      RAID Disks Stripe Status  Cache"
   echo "  ========== ========= ==== ===== ====== ======= ======="
   for dev in $(awk '/Logical device number/{print $4}' $file); do
      sed -n -e "/^Logical device .* ${dev}$/,/^$\|^Logical device number/p" $file \
      | awk '
         /Logical device name/               {d=$5}
         /Size/                              {z=$3 " " $4}
         /RAID level/                        {r=$4}
         /Group [0-9]/                       {g++}
         /Stripe-unit size/                  {p=$4 " " $5}
         /Status of logical/                 {s=$6}
         /Write-cache mode.*Ena.*write-back/ {c="On (WB)"}
         /Write-cache mode.*Ena.*write-thro/ {c="On (WT)"}
         /Write-cache mode.*Disabled/        {c="Off"}
         END {
            printf("  %-10s %-9s %4d %5d %-6s %-7s %-7s\n",
               d, z, r, g, p, s, c);
         }'
   done

   # ###########################################################################
   # Physical devices
   # ###########################################################################
   echo
   echo "  PhysiclDev State   Speed         Vendor  Model        Size        Cache"
   echo "  ========== ======= ============= ======= ============ =========== ======="

   # Find the paragraph with physical devices, tabularize with assoc arrays.
   tempresult=""
   sed -n -e '/Physical Device information/,/^$/p' $file \
      | awk -F: '
         /Device #[0-9]/ {
            device=substr($0, index($0, "#"));
            devicenames[device]=device;
         }
         /Device is a/ {
            devices[device ",isa"] = substr($0, index($0, "is a") + 5);
         }
         /State/ {
            devices[device ",state"] = substr($2, 2);
         }
         /Transfer Speed/ {
            devices[device ",speed"] = substr($2, 2);
         }
         /Vendor/ {
            devices[device ",vendor"] = substr($2, 2);
         }
         /Model/ {
            devices[device ",model"] = substr($2, 2);
         }
         /Size/ {
            devices[device ",size"] = substr($2, 2);
         }
         /Write Cache/ {
            if ( $2 ~ /Enabled .write-back./ )
               devices[device ",cache"] = "On (WB)";
            else
               if ( $2 ~ /Enabled .write-th/ )
                  devices[device ",cache"] = "On (WT)";
               else
                  devices[device ",cache"] = "Off";
         }
         END {
            for ( device in devicenames ) {
               if ( devices[device ",isa"] ~ /Hard drive/ ) {
                  printf("  %-10s %-7s %-13s %-7s %-12s %-11s %-7s\n",
                     devices[device ",isa"],
                     devices[device ",state"],
                     devices[device ",speed"],
                     devices[device ",vendor"],
                     devices[device ",model"],
                     devices[device ",size"],
                     devices[device ",cache"]);
               }
            }
         }'
}

# ##############################################################################
# Parse the output of "lsiutil -i -s".
# ##############################################################################
parse_fusionmpt_lsiutil () {
   local file=$1
   echo
   awk '/LSI.*Firmware/ { print " ", $0 }' $file
   grep . $file | sed -n -e '/B___T___L/,$ {s/^/  /; p}'
}

# ##############################################################################
# Parse the output of MegaCli64 -AdpAllInfo -aALL from /tmp/percona-toolkit.
# ##############################################################################
parse_lsi_megaraid_adapter_info () {
   local file=$1
   name=$(awk -F: '/Product Name/{print substr($2, 2)}' $file);
   int=$(awk '/Host Interface/{print $4}' $file);
   prt=$(awk '/Number of Backend Port/{print $5}' $file);
   bbu=$(awk '/^BBU             :/{print $3}' $file);
   mem=$(awk '/Memory Size/{print $4}' $file);
   vdr=$(awk '/Virtual Drives/{print $4}' $file);
   dvd=$(awk '/Degraded/{print $3}' $file);
   phy=$(awk '/^  Disks/{print $3}' $file);
   crd=$(awk '/Critical Disks/{print $4}' $file);
   fad=$(awk '/Failed Disks/{print $4}' $file);
   name_val Model "${name}, ${int} interface, ${prt} ports"
   name_val Cache "${mem} Memory, BBU ${bbu}"
}

# ##############################################################################
# Parse the output (saved in /tmp/percona-toolkit) of
# /opt/MegaRAID/MegaCli/MegaCli64 -AdpBbuCmd -GetBbuStatus -aALL
# ##############################################################################
parse_lsi_megaraid_bbu_status () {
   local file=$1
   charge=$(awk '/Relative State/{print $5}' $file);
   temp=$(awk '/^Temperature/{print $2}' $file);
   soh=$(awk '/isSOHGood:/{print $2}' $file);
   name_val BBU "${charge}% Charged, Temperature ${temp}C, isSOHGood=${soh}"
}

# ##############################################################################
# Parse physical devices from the output (saved in /tmp/percona-toolkit) of
# /opt/MegaRAID/MegaCli/MegaCli64 -LdPdInfo -aALL
# OR, it will also work with the output of
# /opt/MegaRAID/MegaCli/MegaCli64 -PDList -aALL
# ##############################################################################
parse_lsi_megaraid_devices () {
   local file=$1
   echo
   echo "  PhysiclDev Type State   Errors Vendor  Model        Size"
   echo "  ========== ==== ======= ====== ======= ============ ==========="
   for dev in $(awk '/Device Id/{print $3}' $file); do
      sed -e '/./{H;$!d;}' -e "x;/Device Id: ${dev}/!d;" $file \
      | awk '
         /Media Type/                        {d=substr($0, index($0, ":") + 2)}
         /PD Type/                           {t=$3}
         /Firmware state/                    {s=$3}
         /Media Error Count/                 {me=$4}
         /Other Error Count/                 {oe=$4}
         /Predictive Failure Count/          {pe=$4}
         /Inquiry Data/                      {v=$3; m=$4;}
         /Raw Size/                          {z=$3}
         END {
            printf("  %-10s %-4s %-7s %6s %-7s %-12s %-7s\n",
               substr(d, 0, 10), t, s, me "/" oe "/" pe, v, m, z);
         }'
   done
}

# ##############################################################################
# Parse virtual devices from the output (saved in /tmp/percona-toolkit) of
# /opt/MegaRAID/MegaCli/MegaCli64 -LdPdInfo -aALL
# OR, it will also work with the output of
# /opt/MegaRAID/MegaCli/MegaCli64 -LDInfo -Lall -aAll
# ##############################################################################
parse_lsi_megaraid_virtual_devices () {
   local file=$1
   # Somewhere on the Internet, I found the following guide to understanding the
   # RAID level, but I don't know the source anymore.
   #    Primary-0, Secondary-0, RAID Level Qualifier-0 = 0
   #    Primary-1, Secondary-0, RAID Level Qualifier-0 = 1
   #    Primary-5, Secondary-0, RAID Level Qualifier-3 = 5
   #    Primary-1, Secondary-3, RAID Level Qualifier-0 = 10
   # I am not sure if this is always correct or not (it seems correct).  The
   # terminology MegaRAID uses is not clear to me, and isn't documented that I
   # am aware of.  Anyone who can clarify the above, please contact me.
   echo
   echo "  VirtualDev Size      RAID Level Disks SpnDpth Stripe Status  Cache"
   echo "  ========== ========= ========== ===== ======= ====== ======= ========="
   awk '
      /^Virtual Disk:/ {
         device              = $3;
         devicenames[device] = device;
      }
      /Number Of Drives/ {
         devices[device ",numdisks"] = substr($0, index($0, ":") + 1);
      }
      /^Name:/ {
         devices[device ",name"] = $2 > "" ? $2 : "(no name)";
      }
      /RAID Level/ {
         devices[device ",primary"]   = substr($3, index($3, "-") + 1, 1);
         devices[device ",secondary"] = substr($4, index($4, "-") + 1, 1);
         devices[device ",qualifier"] = substr($NF, index($NF, "-") + 1, 1);
      }
      /Span Depth/ {
         devices[device ",spandepth"] = substr($2, index($2, ":") + 1);
      }
      /Number of Spans/ {
         devices[device ",numspans"] = $4;
      }
      /^Size:/ {
         devices[device ",size"] = substr($0, index($0, ":") + 1);
      }
      /^State:/ {
         devices[device ",state"] = $2;
      }
      /^Stripe Size:/ {
         devices[device ",stripe"] = $3;
      }
      /^Current Cache Policy/ {
         devices[device ",wpolicy"] = $4 ~ /WriteBack/ ? "WB" : "WT";
         devices[device ",rpolicy"] = $5 ~ /ReadAheadNone/ ? "no RA" : "RA";
      }
      END {
         for ( device in devicenames ) {
            raid = 0;
            if ( devices[device ",primary"] == 1 ) {
               raid = 1;
               if ( devices[device ",secondary"] == 3 ) {
                  raid = 10;
               }
            }
            else {
               if ( devices[device ",primary"] == 5 ) {
                  raid = 5;
               }
            }
            printf("  %-10s %-9s %-10s %5d %7s %6s %-7s %s\n",
               device devices[device ",name"],
               devices[device ",size"],
               raid " (" devices[device ",primary"] "-" devices[device ",secondary"] "-" devices[device ",qualifier"] ")",
               devices[device ",numdisks"],
               devices[device ",spandepth"] "-" devices[device ",numspans"],
               devices[device ",stripe"], devices[device ",state"],
               devices[device ",wpolicy"] ", " devices[device ",rpolicy"]);
         }
      }' $file
}

# ##############################################################################
# Simplifies vmstat and aligns it nicely.  We don't need the memory stats, the
# system activity is enough.
# ##############################################################################
format_vmstat () {
   local file=$1
   awk "
      BEGIN {
         format = \"  %2s %2s  %4s %4s %5s %5s %6s %6s %3s %3s %3s %3s %3s\n\";
      }
      /procs/ {
         print  \"  procs  ---swap-- -----io---- ---system---- --------cpu--------\";
      }
      /bo/ {
         printf format, \"r\", \"b\", \"si\", \"so\", \"bi\", \"bo\", \"ir\", \"cs\", \"us\", \"sy\", \"il\", \"wa\", \"st\";
      }
      \$0 !~ /r/ {
            fuzzy_var = \$1;   ${fuzzy_formula}  r   = fuzzy_var;
            fuzzy_var = \$2;   ${fuzzy_formula}  b   = fuzzy_var;
            fuzzy_var = \$7;   ${fuzzy_formula}  si  = fuzzy_var;
            fuzzy_var = \$8;   ${fuzzy_formula}  so  = fuzzy_var;
            fuzzy_var = \$9;   ${fuzzy_formula}  bi  = fuzzy_var;
            fuzzy_var = \$10;  ${fuzzy_formula}  bo  = fuzzy_var;
            fuzzy_var = \$11;  ${fuzzy_formula}  ir  = fuzzy_var;
            fuzzy_var = \$12;  ${fuzzy_formula}  cs  = fuzzy_var;
            fuzzy_var = \$13;                    us  = fuzzy_var;
            fuzzy_var = \$14;                    sy  = fuzzy_var;
            fuzzy_var = \$15;                    il  = fuzzy_var;
            fuzzy_var = \$16;                    wa  = fuzzy_var;
            fuzzy_var = \$17;                    st  = fuzzy_var;
            printf format, r, b, si, so, bi, bo, ir, cs, us, sy, il, wa, st;
         }
   " $file
}

# ##############################################################################
# The main() function is called at the end of the script.  This makes it
# testable.  Major bits of parsing are separated into functions for testability.
# As a general rule, we cannot 'cp' files from /proc, because they might be
# empty afterwards.  (I've seen 'cp /proc/cpuinfo' create an empty file.)  But
# 'cat' works okay.
# ##############################################################################
main () {

   # Begin by setting the $PATH to include some common locations that are not
   # always in the $PATH, including the "sbin" locations, and some common
   # locations for proprietary management software, such as RAID controllers.
   export PATH="${PATH}:/usr/local/bin:/usr/bin:/bin:/usr/libexec"
   export PATH="${PATH}:/usr/local/sbin:/usr/sbin:/sbin"
   export PATH="${PATH}:/usr/StorMan/:/opt/MegaRAID/MegaCli/";

   # Set up temporary files.
   temp_files "rm"
   temp_files "touch"
   section Percona_Toolkit_System_Summary_Report

   # ########################################################################
   # Grab a bunch of stuff and put it into temp files for later.
   # ########################################################################
   sysctl -a > /tmp/percona-toolkit.sysctl 2>/dev/null

   # ########################################################################
   # General date, time, load, etc
   # ########################################################################
   platform="$(uname -s)"
   name_val "Date" "`date -u +'%F %T UTC'` (local TZ: `date +'%Z %z'`)"
   name_val "Hostname" "$(uname -n)"
   name_val "Uptime" "$(uptime | awk '{print substr($0, index($0, "up") + 3)}')"
   if which dmidecode > /dev/null 2>&1; then
      vendor="$(dmidecode -s system-manufacturer 2>/dev/null | sed 's/ *$//g')"
      if [ "${vendor}" ]; then
         product="$(dmidecode -s system-product-name 2>/dev/null | sed 's/ *$//g')"
         version="$(dmidecode -s system-version 2>/dev/null | sed 's/ *$//g')"
         chassis="$(dmidecode -s chassis-type 2>/dev/null | sed 's/ *$//g')"
         system="${vendor}; ${product}; v${version} (${chassis})"
         name_val "System" "${system}";
         servicetag="$(dmidecode -s system-serial-number 2>/dev/null | sed 's/ *$//g')"
         name_val "Service Tag" "${servicetag:-Not found}";
      fi
   fi
   name_val "Platform" "${platform}"
   if [ "${platform}" = "SunOS" ]; then
      if which zonename >/dev/null 2>&1 ; then
         name_val "Zonename" "$(zonename)"
      fi
   fi

   # Try to find all sorts of different files that say what the release is.
   if [ "${platform}" = "Linux" ]; then
      kernel="$(uname -r)"
      if [ -e /etc/fedora-release ]; then
         release=$(cat /etc/fedora-release);
      elif [ -e /etc/redhat-release ]; then
         release=$(cat /etc/redhat-release);
      elif [ -e /etc/system-release ]; then
         release=$(cat /etc/system-release);
      elif which lsb_release >/dev/null 2>&1; then
         release="$(lsb_release -ds) ($(lsb_release -cs))"
      elif [ -e /etc/lsb-release ]; then
         release=$(grep DISTRIB_DESCRIPTION /etc/lsb-release |awk -F'=' '{print $2}' |sed 's#"##g');
      elif [ -e /etc/debian_version ]; then
         release="Debian-based version $(cat /etc/debian_version)";
         if [ -e /etc/apt/sources.list ]; then
             code=`cat /etc/apt/sources.list |awk  '/^deb/ {print $3}' |awk -F/ '{print $1}'| awk 'BEGIN {FS="|"}{print $1}' | sort | uniq -c | sort -rn |head -n1 |awk '{print $2}'`
             release="${release} (${code})"
      fi
      elif ls /etc/*release >/dev/null 2>&1; then
         if grep -q DISTRIB_DESCRIPTION /etc/*release; then
            release=$(grep DISTRIB_DESCRIPTION /etc/*release | head -n1);
         else
            release=$(cat /etc/*release | head -n1);
         fi
      fi
   elif [ "${platform}" = "FreeBSD" ]; then
      release="$(uname -r)"
      kernel="$(sysctl -n kern.osrevision)"
   elif [ "${platform}" = "SunOS" ]; then
      release="$(head -n1 /etc/release)"
      if [ -z "${release}" ]; then
         release="$(uname -r)"
      fi
      kernel="$(uname -v)"
   fi
   name_val Release "${release}"
   name_val Kernel "${kernel}"

   CPU_ARCH='32-bit'
   OS_ARCH='32-bit'
   if [ "${platform}" = "Linux" ]; then
      if grep -q ' lm ' /proc/cpuinfo; then
         CPU_ARCH='64-bit'
      fi
   elif [ "${platform}" = "FreeBSD" ]; then
      if sysctl hw.machine_arch | grep -v 'i[36]86' >/dev/null; then
         CPU_ARCH='64-bit'
      fi
   elif [ "${platform}" = "SunOS" ]; then
      if isainfo -b | grep 64 >/dev/null ; then
         CPU_ARCH="64-bit"
      fi
   fi
   if file /bin/sh | grep '64-bit' >/dev/null; then
      OS_ARCH='64-bit'
   fi
   name_val "Architecture" "CPU = $CPU_ARCH, OS = $OS_ARCH"

   # Threading library
   if [ "${platform}" = "Linux" ]; then
      name_val Threading "$(getconf GNU_LIBPTHREAD_VERSION)"
   fi
   if [ -x /lib/libc.so.6 ]; then
      name_val "Compiler" "$(/lib/libc.so.6 | grep 'Compiled by' | cut -c13-)"
   fi

   if [ "${platform}" = "Linux" ]; then
      if getenforce >/dev/null 2>&1; then
         getenforce="$(getenforce 2>&1)";
      fi
      name_val "SELinux" "${getenforce:-No SELinux detected}";
   fi

   # We look in dmesg for virtualization information first, because it's often
   # available to non-root users and usually has telltale signs.  It's most
   # reliable to look at /var/log/dmesg if possible.  There are a number of
   # other ways to find out if a system is virtualized.
   cat /var/log/dmesg > /tmp/percona-toolkit 2>/dev/null
   if [ ! -s /tmp/percona-toolkit ]; then
      dmesg > /tmp/percona-toolkit 2>/dev/null
   fi
   if [ -s /tmp/percona-toolkit ]; then
      virt="$(parse_virtualization_dmesg /tmp/percona-toolkit)"
   fi
   if [ -z "${virt}" ]; then
      if which lspci >/dev/null 2>&1; then
         lspci > /tmp/percona-toolkit 2>/dev/null
         if grep -qi virtualbox /tmp/percona-toolkit; then
            virt=VirtualBox
         elif grep -qi vmware /tmp/percona-toolkit; then
            virt=VMWare
         elif [ -e /proc/user_beancounters ]; then
            virt="OpenVZ/Virtuozzo"
         fi
      fi
   elif [ "${platform}" = "FreeBSD" ]; then
      if ps -o stat | grep J ; then
         virt="FreeBSD Jail"
      fi
   elif [ "${platform}" = "SunOS" ]; then
      if which prtdiag >/dev/null 2>&1 && prtdiag > /tmp/percona-toolkit.prtdiag 2>/dev/null; then
         virt="$(parse_virtualization_generic /tmp/percona-toolkit.prtdiag)"
      elif which smbios >/dev/null 2>&1 && smbios > /tmp/percona-toolkit.smbios 2>/dev/null; then
         virt="$(parse_virtualization_generic /tmp/percona-toolkit.smbios)"
      fi
   fi
   name_val Virtualized "${virt:-No virtualization detected}"

   # ########################################################################
   # Processor/CPU, Memory, Swappiness, dmidecode
   # ########################################################################
   section Processor
   if [ -f /proc/cpuinfo ]; then
      cat /proc/cpuinfo > /tmp/percona-toolkit 2>/dev/null
      parse_proc_cpuinfo /tmp/percona-toolkit
   elif [ "${platform}" = "FreeBSD" ]; then
      parse_sysctl_cpu_freebsd /tmp/percona-toolkit.sysctl
   elif [ "${platform}" = "SunOS" ]; then
      psrinfo -v > /tmp/percona-toolkit
      parse_psrinfo_cpus /tmp/percona-toolkit
      # TODO: prtconf -v actually prints the CPU model name etc.
   fi

   section Memory
   if [ "${platform}" = "Linux" ]; then
      free -b > /tmp/percona-toolkit
      cat /proc/meminfo >> /tmp/percona-toolkit
      parse_free_minus_b /tmp/percona-toolkit
   elif [ "${platform}" = "FreeBSD" ]; then
      parse_memory_sysctl_freebsd /tmp/percona-toolkit.sysctl
   elif [ "${platform}" = "SunOS" ]; then
      name_val Memory "$(prtconf | awk -F: '/Memory/{print $2}')"
   fi

   rss=$(ps -eo rss 2>/dev/null | awk '/[0-9]/{total += $1 * 1024} END {print total}')
   name_val UsedRSS "$(shorten ${rss} 1)"

   if [ "${platform}" = "Linux" ]; then
      name_val Swappiness "$(sysctl vm.swappiness 2>&1)"
      name_val DirtyPolicy "$(sysctl vm.dirty_ratio 2>&1), $(sysctl vm.dirty_background_ratio 2>&1)"
      if sysctl vm.dirty_bytes > /dev/null 2>&1; then
         name_val DirtyStatus "$(sysctl vm.dirty_bytes 2>&1), $(sysctl vm.dirty_background_bytes 2>&1)"
      fi
   fi

   if which dmidecode >/dev/null 2>&1 && dmidecode > /tmp/percona-toolkit 2>/dev/null; then
      parse_dmidecode_mem_devices /tmp/percona-toolkit
   fi

   # ########################################################################
   # Disks, RAID, Filesystems
   # ########################################################################
   # TODO: Add info about software RAID

   if echo "${PT_SUMMARY_SKIP}" | grep -v MOUNT >/dev/null; then
      if [ "${platform}" != "SunOS" ]; then
         section "Mounted_Filesystems"
         cmd="df -h"
         if [ "${platform}" = "Linux" ]; then
            cmd="df -h -P"
         fi
         $cmd | sort > /tmp/percona-toolkit2
         mount | sort | join /tmp/percona-toolkit2 - > /tmp/percona-toolkit
         parse_filesystems /tmp/percona-toolkit "${platform}"
      fi
   fi

   if [ "${platform}" = "Linux" ]; then
      section "Disk_Schedulers_And_Queue_Size"
      echo "" > /tmp/percona-toolkit
      for disk in $(ls /sys/block/ | grep -v -e ram -e loop -e 'fd[0-9]'); do
         if [ -e "/sys/block/${disk}/queue/scheduler" ]; then
            name_val "${disk}" "$(cat /sys/block/${disk}/queue/scheduler | grep -o '\[.*\]') $(cat /sys/block/${disk}/queue/nr_requests)"
            fdisk -l "/dev/${disk}" >> /tmp/percona-toolkit 2>/dev/null
         fi
      done

      # Relies on /tmp/percona-toolkit having data from the Disk Schedulers loop.
      section "Disk_Partioning"
      parse_fdisk /tmp/percona-toolkit

      section "Kernel_Inode_State"
      for file in dentry-state file-nr inode-nr; do
         name_val "${file}" "$(cat /proc/sys/fs/${file} 2>&1)"
      done

      section "LVM_Volumes"

      if which lvs >/dev/null 2>&1 && test -x "$(which lvs)"; then
         lvs 2>&1
      else
         echo "Cannot execute 'lvs'";
      fi
   fi

   section "RAID_Controller"

   # ########################################################################
   # We look in lspci first because it's more reliable, then dmesg, because it's
   # often available to non-root users.  It's most reliable to look at
   # /var/log/dmesg if possible.
   # ########################################################################
   if which lspci >/dev/null 2>&1 && lspci > /tmp/percona-toolkit 2>/dev/null; then
      controller="$(parse_raid_controller_lspci /tmp/percona-toolkit)"
   fi
   if [ -z "${controller}" ]; then
      cat /var/log/dmesg > /tmp/percona-toolkit 2>/dev/null
      if [ ! -s /tmp/percona-toolkit ]; then
         dmesg > /tmp/percona-toolkit 2>/dev/null
      fi
      controller="$(parse_raid_controller_dmesg /tmp/percona-toolkit)"
   fi

   name_val Controller "${controller:-No RAID controller detected}"

   # ########################################################################
   # Attempt to get, parse, and print RAID controller status from possibly
   # proprietary management software.  Any executables that are normally stored
   # in a weird location, such as /usr/StorMan/arcconf, should have their
   # location added to $PATH at the beginning of main().
   # ########################################################################
   notfound=""
   if [ "${controller}" = "AACRAID" ]; then
      if arcconf getconfig 1 > /tmp/percona-toolkit 2>/dev/null; then
         parse_arcconf /tmp/percona-toolkit
      elif ! which arcconf >/dev/null 2>&1; then
         notfound="e.g. http://www.adaptec.com/en-US/support/raid/scsi_raid/ASR-2120S/"
      fi
   elif [ "${controller}" = "HP Smart Array" ]; then
      if hpacucli ctrl all show config > /tmp/percona-toolkit 2>/dev/null; then
         parse_hpacucli /tmp/percona-toolkit
      elif ! which hpacucli >/dev/null 2>&1; then
         notfound="your package repository or the manufacturer's website"
      fi
   elif [ "${controller}" = "LSI Logic MegaRAID SAS" ]; then
      if MegaCli64 -AdpAllInfo -aALL -NoLog > /tmp/percona-toolkit 2>/dev/null; then
         parse_lsi_megaraid_adapter_info /tmp/percona-toolkit
      elif ! which MegaCli64 >/dev/null 2>&1; then
         notfound="your package repository or the manufacturer's website"
      fi
      if MegaCli64 -AdpBbuCmd -GetBbuStatus -aALL -NoLog > /tmp/percona-toolkit 2>/dev/null; then
         parse_lsi_megaraid_bbu_status /tmp/percona-toolkit
      fi
      if MegaCli64 -LdPdInfo -aALL -NoLog > /tmp/percona-toolkit 2>/dev/null; then
         parse_lsi_megaraid_virtual_devices /tmp/percona-toolkit
         parse_lsi_megaraid_devices /tmp/percona-toolkit
      fi
   fi

   if [ "${notfound}" ]; then
      echo "   RAID controller software not found; try getting it from"
      echo "   ${notfound}"
   fi

   if echo "${PT_SUMMARY_SKIP}" | grep -v NETWORK >/dev/null; then
      # #####################################################################
      # Network stuff
      # #####################################################################
      if [ "${platform}" = "Linux" ]; then
         section Network_Config
         if which lspci > /dev/null 2>&1 && lspci > /tmp/percona-toolkit 2>/dev/null; then
            parse_ethernet_controller_lspci /tmp/percona-toolkit
         fi
         if sysctl net.ipv4.tcp_fin_timeout > /dev/null 2>&1; then
            name_val "FIN Timeout" "$(sysctl net.ipv4.tcp_fin_timeout)"
            name_val "Port Range" "$(sysctl net.ipv4.ip_local_port_range)"
         fi
      fi

      # TODO cat /proc/sys/net/ipv4/ip_conntrack_max ; it might be
      # /proc/sys/net/netfilter/nf_conntrack_max or /proc/sys/net/nf_conntrack_max
      # in new kernels like Fedora 12?

      if which ip >/dev/null 2>&1 && ip -s link > /tmp/percona-toolkit 2>/dev/null; then
         section Interface_Statistics
         parse_ip_s_link /tmp/percona-toolkit
      fi

      if [ "${platform}" = "Linux" ]; then
         section Network_Connections
         if netstat -antp > /tmp/percona-toolkit 2>/dev/null; then
            parse_netstat /tmp/percona-toolkit
         fi
      fi
   fi

   # ########################################################################
   # Processes, load, etc
   # ########################################################################
   if echo "${PT_SUMMARY_SKIP}" | grep -v PROCESS >/dev/null; then
      section Top_Processes
      if which prstat > /dev/null 2>&1; then
         prstat | head
      elif which top > /dev/null 2>&1 ; then
         cmd="top -bn 1"
         if [ "${platform}" = "FreeBSD" ]; then
            cmd="top -b -d 1"
         fi
         $cmd | sed -e 's# *$##g' -e '/./{H;$!d;}' -e 'x;/PID/!d;' | grep . | head
      fi
      if which vmstat > /dev/null 2>&1 ; then
         section "Simplified_and_fuzzy_rounded_vmstat_(wait_please)"
         vmstat 1 5 > /tmp/percona-toolkit
         if [ "${platform}" = "Linux" ]; then
            format_vmstat /tmp/percona-toolkit
         else
            # TODO: simplify/format for other platforms
            cat /tmp/percona-toolkit
         fi
      fi
   fi

   # ########################################################################
   # All done.  Signal the end so it's explicit.
   # ########################################################################
   temp_files "rm"
   temp_files "check"
   section The_End
}

# Execute the program if it was not included from another file.  This makes it
# possible to include without executing, and thus test.
if [ "$(basename "$0")" = "pt-summary" ] || [ "$(basename "$0")" = "bash" -a "$_" = "$0" ]; then
    main $@
fi

# ############################################################################
# Documentation
# ############################################################################
:<<'DOCUMENTATION'
=pod

=head1 NAME

pt-summary - Summarize system information in a nice way.

=head1 SYNOPSIS

Usage: pt-summary

pt-summary conveniently summarizes the status and configuration of a server.
It is not a tuning tool or diagnosis tool.  It produces a report that is easy
to diff and can be pasted into emails without losing the formatting.  This
tool works well on Linux systems.

Download and run:

   wget http://percona.com/get/pt-summary
   bash ./pt-summary

Download and run in a single step:

   wget -O- http://percona.com/get/summary | bash

=head1 RISKS

The following section is included to inform users about the potential risks,
whether known or unknown, of using this tool.  The two main categories of risks
are those created by the nature of the tool (e.g. read-only tools vs. read-write
tools) and those created by bugs.

pt-summary is a read-only tool.  It should be very low-risk.

At the time of this release, we know of no bugs that could cause serious harm
to users.

The authoritative source for updated information is always the online issue
tracking system.  Issues that affect this tool will be marked as such.  You can
see a list of such issues at the following URL:
L<http://www.percona.com/bugs/pt-summary>.

See also L<"BUGS"> for more information on filing bugs and getting help.

=head1 DESCRIPTION

pt-summary runs a large variety of commands to inspect system status and
configuration, saves the output into files in /tmp, and then runs Unix
commands on these results to format them nicely.  It works best when
executed as a privileged user, but will also work without privileges,
although some output might not be possible to generate without root.

=head1 OPTIONS

This tool does not have any command-line options.

=head1 ENVIRONMENT

The PT_SUMMARY_SKIP environment variable specifies a comma-separated list
of things to skip:

  MOUNT:   Don't print out mounted filesystems and disk fullness.
  NETWORK: Don't print out information on network controllers & config.
  PROCESS: Don't print out top processes and vmstat information.

=head1 SYSTEM REQUIREMENTS

This tool requires the Bourne shell (F</bin/sh>).

=head1 BUGS

For a list of known bugs, see L<http://www.percona.com/bugs/pt-summary>.

Please report bugs at L<https://bugs.launchpad.net/percona-toolkit>.
Include the following information in your bug report:

=over

=item * Complete command-line used to run the tool

=item * Tool L<"--version">

=item * MySQL version of all servers involved

=item * Output from the tool including STDERR

=item * Input files (log/dump/config files, etc.)

=back

If possible, include debugging output by running the tool with C<PTDEBUG>;
see L<"ENVIRONMENT">.

=head1 DOWNLOADING

Visit L<http://www.percona.com/software/percona-toolkit/> to download the
latest release of Percona Toolkit.  Or, get the latest release from the
command line:

   wget percona.com/get/percona-toolkit.tar.gz

   wget percona.com/get/percona-toolkit.rpm

   wget percona.com/get/percona-toolkit.deb

You can also get individual tools from the latest release:

   wget percona.com/get/TOOL

Replace C<TOOL> with the name of any tool.

=head1 AUTHORS

Baron Schwartz and Kevin van Zonneveld (http://kevin.vanzonneveld.net)

=head1 ABOUT PERCONA TOOLKIT

This tool is part of Percona Toolkit, a collection of advanced command-line
tools developed by Percona for MySQL support and consulting.  Percona Toolkit
was forked from two projects in June, 2011: Maatkit and Aspersa.  Those
projects were created by Baron Schwartz and developed primarily by him and
Daniel Nichter, both of whom are employed by Percona.  Visit
L<http://www.percona.com/software/> for more software developed by Percona.

=head1 COPYRIGHT, LICENSE, AND WARRANTY

This program is copyright 2010-2011 Baron Schwartz, 2011 Percona Inc.
Feedback and improvements are welcome.

THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
systems, you can issue `man perlgpl' or `man perlartistic' to read these
licenses.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA.

=head1 VERSION

pt-summary 1.0.1

=cut

DOCUMENTATION
